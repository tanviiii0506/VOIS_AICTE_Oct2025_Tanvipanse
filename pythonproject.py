"""AIRBNBHOTELBOOKINGANALYSIS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WXzUwR3t26_Y87ZpsNHyloY4Z82_I1VW
"""

# Airbnb Hotel Booking Data Analysis Project
# Student: Tanmoy Santra

# Import required libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings('ignore')

# Load the dataset
print("Loading Airbnb NYC Dataset...")
df = pd.read_excel('1730285881-Airbnb_Open_Data.xlsx')
print(f"Dataset loaded successfully!")
print(f"Dataset shape: {df.shape}")

# Display basic information
print("\n=== DATASET OVERVIEW ===")
print(f"Total records: {len(df)}")
print(f"Total columns: {len(df.columns)}")
print("\nColumn names:")
for i, col in enumerate(df.columns, 1):
    print(f"{i}. {col}")

# Check for missing values
print("\n=== DATA QUALITY CHECK ===")
missing_data = df.isnull().sum()
print("Missing values per column:")
for col, missing in missing_data.items():
    if missing > 0:
        percentage = (missing / len(df) * 100)
        print(f"• {col}: {missing} ({percentage:.2f}%)")

# Data cleaning
print("\n=== DATA CLEANING ===")
# Clean price data
df['price_clean'] = df['price'].astype(str).str.replace('$', '').str.replace(',', '')
df['price_clean'] = pd.to_numeric(df['price_clean'], errors='coerce')

# Clean service fee data
df['service_fee_clean'] = df['service fee'].astype(str).str.replace('$', '').str.replace(',', '')
df['service_fee_clean'] = pd.to_numeric(df['service_fee_clean'], errors='coerce')

# Clean construction year data
df['construction_year_clean'] = df['Construction year']

print("Data cleaning completed!")

# ANALYSIS SECTION
print("\n" + "="*80)
print("AIRBNB NYC DATA ANALYSIS - RESEARCH QUESTIONS")
print("="*80)

# Question 1: Property Types
print("\nQUESTION 1: What are the different property types in the Dataset?")
print("-" * 60)
room_types = df['room type'].value_counts()
print("Property Types Distribution:")
for room_type, count in room_types.items():
    percentage = (count / len(df) * 100)
    print(f"• {room_type}: {count} listings ({percentage:.2f}%)")

# Question 2: Neighbourhood Groups by Listing Count
print("\nQUESTION 2: Which neighbourhood group has the highest number of listings?")
print("-" * 60)
neighbourhood_counts = df['neighbourhood group'].value_counts()
print("Neighbourhood Groups by Listing Count:")
for i, (neighbourhood, count) in enumerate(neighbourhood_counts.items(), 1):
    print(f"{i}. {neighbourhood}: {count} listings")
print(f"\nAnswer: {neighbourhood_counts.index[0]} has the highest number of listings ({neighbourhood_counts.iloc[0]} listings)")

# Question 3: Average Prices by Neighbourhood
print("\nQUESTION 3: Which neighbourhood group has the highest average prices?")
print("-" * 60)
avg_prices = df.groupby('neighbourhood group')['price_clean'].agg(['mean', 'count']).round(2)
avg_prices = avg_prices.sort_values('mean', ascending=False)
print("Average Prices by Neighbourhood Group:")
for neighbourhood, data in avg_prices.iterrows():
    print(f"• {neighbourhood}: ${data['mean']} (based on {int(data['count'])} listings)")
print(f"\nAnswer: {avg_prices.index[0]} has the highest average price (${avg_prices.iloc[0]['mean']})")

# Question 4: Construction Year vs Price Correlation
print("\nQUESTION 4: Is there a relationship between construction year and price?")
print("-" * 60)
# Filter valid data
valid_data = df[(df['construction_year_clean'].notna()) &
                (df['price_clean'].notna()) &
                (df['construction_year_clean'] >= 1800) &
                (df['construction_year_clean'] <= 2023)]

if len(valid_data) > 0:
    correlation = valid_data['construction_year_clean'].corr(valid_data['price_clean'])
    print(f"Correlation between Construction Year and Price: {correlation:.4f}")

    # Decade analysis
    valid_data['decade'] = (valid_data['construction_year_clean'] // 10) * 10
    decade_analysis = valid_data.groupby('decade')['price_clean'].agg(['mean', 'count']).round(2)
    decade_analysis = decade_analysis[decade_analysis['count'] >= 10]

    print("\nAverage Prices by Construction Decade:")
    for decade, data in decade_analysis.iterrows():
        print(f"• {int(decade)}s: ${data['mean']} (based on {int(data['count'])} listings)")

    print(f"\nAnswer: {'Very weak positive' if correlation > 0 else 'Negative'} correlation ({correlation:.4f})")
else:
    print("Insufficient data for correlation analysis")

# Question 5: Top Hosts
print("\nQUESTION 5: Who are the top 10 hosts by calculated host listing count?")
print("-" * 60)
top_hosts = df.groupby(['host id', 'host name'])['calculated host listings count'].first().sort_values(ascending=False).head(10)
print("Top 10 Hosts by Listing Count:")
for i, ((host_id, host_name), count) in enumerate(top_hosts.items(), 1):
    host_display = host_name if pd.notna(host_name) else f"Host ID {host_id}"
    print(f"{i}. {host_display}: {int(count)} listings")

# Question 6: Host Verification vs Reviews
print("\nQUESTION 6: Are hosts with verified identities more likely to receive positive reviews?")
print("-" * 60)
verification_data = df[(df['host_identity_verified'].notna()) & (df['review rate number'].notna())]
if len(verification_data) > 0:
    review_analysis = verification_data.groupby('host_identity_verified')['review rate number'].agg(['mean', 'count']).round(3)
    print("Review Ratings by Verification Status:")
    for status, data in review_analysis.iterrows():
        print(f"• {status.title()}: {data['mean']}/5 (based on {int(data['count'])} reviews)")

    if len(review_analysis) >= 2:
        verified_avg = review_analysis.loc['verified', 'mean'] if 'verified' in review_analysis.index else 0
        unverified_avg = review_analysis.loc['unconfirmed', 'mean'] if 'unconfirmed' in review_analysis.index else 0
        if verified_avg > 0 and unverified_avg > 0:
            difference = verified_avg - unverified_avg
            print(f"\nAnswer: Verified hosts have {difference:.3f} points {'higher' if difference > 0 else 'lower'} average rating")

# Question 7: Price vs Service Fee SCATTER PLOT
print("\nQUESTION 7: Is there a correlation between listing price and service fee?")
print("-" * 60)
fee_data = df[(df['price_clean'].notna()) & (df['service_fee_clean'].notna())]
fee_data = fee_data[(fee_data['price_clean'] > 0) & (fee_data['service_fee_clean'] > 0)]
fee_data = fee_data[(fee_data['price_clean'] < 2000) & (fee_data['service_fee_clean'] < 400)]  # Remove outliers

if len(fee_data) > 0:
    # Create scatter plot
    plt.figure(figsize=(10, 8))
    plt.scatter(fee_data['price_clean'], fee_data['service_fee_clean'],
                alpha=0.6, c='#3498DB', s=20)
    plt.title('Relationship between Listing Price and Service Fee', fontsize=16, fontweight='bold')
    plt.xlabel('Listing Price ($)', fontsize=12)
    plt.ylabel('Service Fee ($)', fontsize=12)

    # Add trend line
    z = np.polyfit(fee_data['price_clean'], fee_data['service_fee_clean'], 1)
    p = np.poly1d(z)
    plt.plot(fee_data['price_clean'], p(fee_data['price_clean']), "r--", alpha=0.8, linewidth=2)

    # Calculate and display correlation
    correlation = fee_data['price_clean'].corr(fee_data['service_fee_clean'])
    plt.text(0.05, 0.95, f'Correlation: {correlation:.4f}', transform=plt.gca().transAxes,
             bbox=dict(boxstyle="round,pad=0.3", facecolor="yellow", alpha=0.7),
             fontsize=12, fontweight='bold')

    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.show()

    # Calculate statistics
    avg_price = fee_data['price_clean'].mean()
    avg_fee = fee_data['service_fee_clean'].mean()
    fee_percentage = (avg_fee / avg_price * 100) if avg_price > 0 else 0

    print(f"Correlation between Price and Service Fee: {correlation:.4f}")
    print(f"Average Price: ${avg_price:.2f}")
    print(f"Average Service Fee: ${avg_fee:.2f}")
    print(f"Service Fee as % of Price: {fee_percentage:.2f}%")

# Question 8: Reviews by Room Type PIE CHART
print("\nQUESTION 8: What is the average review rate by neighbourhood group and room type?")
print("-" * 60)
review_data = df[df['review rate number'].notna()]

if len(review_data) > 0:
    # Create pie chart for review distribution by room type
    room_reviews = review_data.groupby('room type')['review rate number'].mean().round(2)

    plt.figure(figsize=(10, 8))
    colors = ['#FF6B6B', '#4ECDC4', '#45B7D1']
    wedges, texts, autotexts = plt.pie(room_reviews.values, labels=room_reviews.index,
                                      autopct='%1.2f★', colors=colors, startangle=90,
                                      textprops={'fontsize': 12, 'fontweight': 'bold'})

    plt.title('Average Review Ratings by Room Type', fontsize=16, fontweight='bold')

    # Enhance the appearance
    for autotext in autotexts:
        autotext.set_color('white')
        autotext.set_fontweight('bold')

    plt.axis('equal')
    plt.show()

    print("Average Review Rates by Room Type:")
    for room_type, rating in room_reviews.items():
        print(f"• {room_type}: {rating}/5 stars")


# Question 9: Host Listings vs Availability
print("\nQUESTION 9: Are hosts with higher calculated host listings more likely to maintain higher availability?")
print("-" * 60)
availability_data = df[(df['calculated host listings count'].notna()) & (df['availability 365'].notna())]
if len(availability_data) > 0:
    # Correlation
    availability_corr = availability_data['calculated host listings count'].corr(availability_data['availability 365'])
    print(f"Correlation between Host Listing Count and Availability: {availability_corr:.4f}")

    # Categorize hosts
    def categorize_host(count):
        if count <= 1:
            return "Single listing (1)"
        elif count <= 5:
            return "Small host (2-5)"
        elif count <= 20:
            return "Medium host (6-20)"
        else:
            return "Large host (21+)"

    availability_data['host_category'] = availability_data['calculated host listings count'].apply(categorize_host)
    category_analysis = availability_data.groupby('host_category')['availability 365'].agg(['mean', 'count']).round(2)

    print("\nAverage Availability by Host Category:")
    for category, data in category_analysis.iterrows():
        print(f"• {category}: {data['mean']} days (based on {int(data['count'])} hosts)")

# Summary
print("\n" + "="*80)
print("ANALYSIS SUMMARY")
print("="*80)
print(f"Dataset analyzed: {len(df):,} Airbnb listings in NYC")
print("Key Insights:")
print(f"• Most common property type: {room_types.index[0]} ({room_types.iloc[0]} listings)")
print(f"• Highest volume neighbourhood: {neighbourhood_counts.index[0]} ({neighbourhood_counts.iloc[0]} listings)")
print(f"• Highest average price neighbourhood: {avg_prices.index[0]} (${avg_prices.iloc[0]['mean']})")
if len(valid_data) > 0:
    print(f"• Construction year impact on price: {'Minimal' if abs(correlation) < 0.1 else 'Moderate' if abs(correlation) < 0.5 else 'Strong'} (r={correlation:.3f})")

print("\nAnalysis completed successfully!")
print("="*80)

# Optional: Save results to CSV
results_summary = {
    'Question': [
        'Q1: Most Common Property Type',
        'Q2: Highest Listing Count Neighbourhood',
        'Q3: Highest Average Price Neighbourhood',
        'Q4: Construction Year-Price Correlation',
        'Q5: Top Host by Listing Count',
        'Q7: Price-Service Fee Correlation',
        'Q8: Best Reviewed Neighbourhood',
        'Q8: Best Reviewed Room Type'
    ],
    'Answer': [
        f"{room_types.index[0]} ({room_types.iloc[0]} listings)",
        f"{neighbourhood_counts.index[0]} ({neighbourhood_counts.iloc[0]} listings)",
        f"{avg_prices.index[0]} (${avg_prices.iloc[0]['mean']})",
        f"{correlation:.4f}" if 'correlation' in locals() else "Data insufficient",
        f"{top_hosts.index[0][1]} ({int(top_hosts.iloc[0])} listings)" if len(top_hosts) > 0 else "Not available",
        f"{price_fee_corr:.4f}" if 'price_fee_corr' in locals() else "Data insufficient",
        f"{neighbourhood_reviews.index[0]} ({neighbourhood_reviews.iloc[0]}/5)" if 'neighbourhood_reviews' in locals() else "Not available",
        f"{room_reviews.index[0]} ({room_reviews.iloc[0]}/5)" if 'room_reviews' in locals() else "Not available"
    ]
}

results_df = pd.DataFrame(results_summary)
results_df.to_csv('airbnb_analysis_summary.csv', index=False)
print("\nResults saved to 'airbnb_analysis_summary.csv'")